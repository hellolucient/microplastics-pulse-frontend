import React, { useState, useEffect } from 'react';
import WhitepaperSection from '../components/WhitepaperSection'; // Path relative to src/pages/
import MainContent from '../components/MainContent'; // Path relative to src/pages/
import whitepaperContent from '../content/whitepaper.md?raw'; // Path relative to src/pages/

// Define Chapter type
interface Chapter {
  id: string;
  title: string;
  content: string;
}

// Simple function to create slugs (IDs)
const slugify = (text: string): string => {
  return text
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^\w\-]+/g, '') // Keep word chars and hyphens
    .replace(/\-\-+/g, '-')      // Collapse multiple hyphens
    .replace(/^-+/, '')          // Trim leading hyphen
    .replace(/-+$/, '');         // Trim trailing hyphen
};

// Function to parse markdown into chapters (Handles H1 only)
const parseMarkdownChapters = (markdown: string): Chapter[] => {
  console.log('[parseMarkdownChapters] Starting parse...');
  const chapters: Chapter[] = [];
  const sections = markdown.split(/^(#\s+.*)/m);

  if (sections.length > 1) {
    for (let i = 1; i < sections.length; i += 2) {
      const headingLineWithHash = sections[i].trim(); 
      const contentBlock = sections[i + 1] || '';
      const title = headingLineWithHash.replace(/^#\s+/, '').trim();
      const id = slugify(title); // Use the general slugify for the main ID now

      // Use the ORIGINAL heading line for the content
      const content = `${headingLineWithHash}\n${contentBlock.trim()}`;

      if (title && id) { 
        // Log the ID generated by the general slugify function
        console.log(`[parseMarkdownChapters] Found: title='${title}', id='${id}'`); 
        chapters.push({ id, title, content });
      }
    }
  }
  console.log('[parseMarkdownChapters] Finished parse. Chapters found:', chapters.length);
  return chapters;
};

const WhitepaperPage: React.FC = () => {
  const [chapters, setChapters] = useState<Chapter[]>([]);
  const [activeChapterId, setActiveChapterId] = useState<string | null>(null);

  useEffect(() => {
    const parsedChapters = parseMarkdownChapters(whitepaperContent);
    setChapters(parsedChapters);
    
    const hash = window.location.hash.substring(1);
    console.log('[WhitepaperPage Load] Initial hash (Full Slug):', hash);
    
    // Validate the incoming hash against the full slug IDs
    const isValidHash = hash && parsedChapters.some(ch => ch.id === hash); 
    console.log('[WhitepaperPage Load] Is hash valid (comparing full slugs)?', isValidHash);
    
    let initialChapterId = null;
    if (isValidHash) {
      // If hash is valid, use it
      initialChapterId = hash;
    } else if (parsedChapters.length > 0) {
      // If hash is invalid or empty, default to the first chapter's full slug ID
      initialChapterId = parsedChapters[0].id; 
      // Only update the URL hash if we defaulted because the initial hash was *empty*
      if (!hash) { 
        window.history.replaceState(null, '', `#${initialChapterId}`);
      }
    }
    // Set the active ID based on the logic above
    setActiveChapterId(initialChapterId);
    console.log('[WhitepaperPage Load] Setting activeChapterId to (Full Slug):', initialChapterId);

  }, []); // Run only once on mount

  const handleChapterClick = (id: string) => {
    console.log('[handleChapterClick] Clicked ID (Full Slug):', id);
    setActiveChapterId(id); // Set the full slug ID directly
    window.history.pushState(null, '', `#${id}`); 
  };

  // Effect to listen for hash changes (e.g., back/forward button)
  useEffect(() => {
    const handleHashChange = () => {
      const hash = window.location.hash.substring(1);
      console.log('[handleHashChange] Hash changed to (Full Slug):', hash);
      const chapterExists = chapters.some(ch => ch.id === hash);
      console.log('[handleHashChange] Does chapter exist for this hash?', chapterExists);

      if (chapterExists) {
        setActiveChapterId(hash);
        console.log('[handleHashChange] Setting activeChapterId from hash (Full Slug):', hash);
      } else if (!hash && chapters.length > 0) { 
         // If hash is empty, maybe default to first chapter?
         const firstId = chapters[0].id;
         setActiveChapterId(firstId);
         window.history.replaceState(null, '', `#${firstId}`); 
         console.log('[handleHashChange] Hash cleared, defaulting activeChapterId to first chapter:', firstId);
      } 
    };

    window.addEventListener('hashchange', handleHashChange);
    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, [chapters]);

  // Effect to scroll to active chapter heading ID (using full slug)
  useEffect(() => {
    if (activeChapterId) { // activeChapterId is now the full slug
      setTimeout(() => { 
        const element = document.getElementById(activeChapterId); // Target the heading ID directly
        console.log(`[Scroll Effect] Trying to scroll to element with ID (Full Slug): ${activeChapterId}`, element);
        if (element) {
          // Restore simple scrollIntoView - CSS handles the offset
          element.scrollIntoView({ behavior: 'smooth', block: 'start' }); 
        } else {
           console.warn(`[Scroll Effect] Could not find element (${activeChapterId}).`);
        }
      }, 100); 
    }
  }, [activeChapterId]); // Run whenever activeChapterId (the full slug) changes

  const activeChapterContent = chapters.find((ch: Chapter) => ch.id === activeChapterId)?.content || null;

  return (
    // Use flex layout for sidebar + main content
    // flex-1 needed if App.tsx is also flex col
    <div className="flex flex-1">
      {/* Sidebar */}
      {/* Ensure sidebar scrolls independently and stays fixed relative to Header */}
      <aside className="w-72 flex-shrink-0 overflow-y-auto bg-white border-r border-gray-200 p-6 hidden md:block sticky top-[64px] h-[calc(100vh-64px)]">
        <h2 className="text-lg font-semibold mb-6 text-gray-800">Whitepaper Chapters</h2>
        <nav className="space-y-2">
          {chapters.map((chapter: Chapter) => (
            <WhitepaperSection 
              key={chapter.id}
              title={chapter.title}
              isActive={activeChapterId === chapter.id}
              onClick={() => handleChapterClick(chapter.id)}
            />
          ))}
        </nav>
      </aside>

      {/* Main Content Area */}
      {/* This div should handle its own scrolling */}
      <div className="flex-1 overflow-y-auto">
         <MainContent activeChapterContent={activeChapterContent} />
      </div>
    </div>
  );
};

export default WhitepaperPage; 